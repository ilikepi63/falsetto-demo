"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBestFitTable = exports.getPoint = exports.partitionDoesMatch = exports.getTableFromSchema = void 0;
const errors_1 = require("./errors");
/** Function to retrieve the first-most query that
 * can support the schema.
 *
 * @param keys - keys the query uses.
 * @param schema - the schema given
 */
const getTableFromSchema = (exactKeys, rangeKeys, schema) => {
    const viableTables = schema.tables.filter(exports.partitionDoesMatch(exactKeys));
    // if none were found, throw.
    if (viableTables.length < 1)
        throw new errors_1.NoViableTablesError();
    // if there are no range keys, then we just return the first viable table
    if (rangeKeys.length < 1)
        return viableTables[0];
    return exports.getBestFitTable(viableTables, rangeKeys);
};
exports.getTableFromSchema = getTableFromSchema;
/** For a query to be a viable solution to the keys, they must match the partition
 *
 * @param schema
 * @param keys
 */
const partitionDoesMatch = (keys) => (table) => table.partitionKey.map(attr => attr.name).every(key => keys.includes(key));
exports.partitionDoesMatch = partitionDoesMatch;
const getPoint = (keys) => (col) => keys.includes(col.name) ? 1 : 0;
exports.getPoint = getPoint;
const getBestFitTable = (tables, rangeKeys) => {
    let bestFit = tables[0];
    let currentBestFitScore = 0;
    for (let i = 0; i < tables.length; i++) {
        const clusteringColumns = tables[i].clusteringColumns;
        const score = clusteringColumns.map(exports.getPoint(rangeKeys)).reduce((sum, arr) => sum + arr, 0);
        if (score > currentBestFitScore) {
            bestFit = tables[i];
            currentBestFitScore = score;
        }
    }
    return bestFit;
};
exports.getBestFitTable = getBestFitTable;
